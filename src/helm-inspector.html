<!DOCTYPE html>
<!--

This page provides an interactive tree view of a Kubernetes Helm chart and its dependencies.

See https://github.com/melahn/helm-inspector for details

-->
<meta charset="UTF-8">
<style>

    /* Style for the inspector view */
    .inspector {
        fill: lightgoldenrodyellow;
        stroke: steelblue;
        stroke-width: 3px;
        height: 250px;
        width: 400px;
        rx: 8;
        ry: 8;
    }

    /* Style for the rectangles */
    .node rect {
        fill: #fff;
        stroke: black;
        stroke-width: 3px;
        height: 80px;
        width: 200px;
        x: -60;
        y: -40;
        rx: 8; /* I like rounded corners */
        ry: 8; /* I like rounded corners */
    }

    /* Style for default text */
    .node text {
        font: 12px sans-serif;
    }

    /* Style for the text used in the node details */
    .detailstext {
        font: 12px sans-serif;
    }

    /* Style for the links between nodes */
    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 2px;
    }

</style>

<body>

<!-- load the d3.js V5 library -->
<script src="https://d3js.org/d3.v5.min.js"></script>
<script>

    // setup the parameters of the tree
    var margin = {top: 20, right: 90, bottom: 30, left: 120},
        width = 1800 - margin.left - margin.right,
        height = 3000 - margin.top - margin.bottom;

    // create a place holder to show the mode
    var selectorMsgSvg = d3.select("body").append("div").attr("id","sd").append("p").attr("id", "selectorMsg1");
    d3.select("#sd").append("p").attr("id", "selectorMsg2");
    d3.select("#sd").append("p").attr("id", "selectorMsg3");

    // create an svg for the tree to live in
    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate("
            + margin.left + "," + margin.top + ")");

    // 'Navigate' mode is when the user can expand the tree elements by clicking on them
    // 'Inspect' mode is when the user can hover over a node to see the details
    const mode = {
        NAVIGATE: 'Navigate',
        INSPECT: 'Inspect',
    }
    var navMsg1 = "Current Mode: Navigate";
    var navMsg2 = "Click on a node to expand or collapse it";
    var navMsg3 = "Press the 'i' key to go into 'Inspect' mode";
    var insMsg1 = "Current Mode: Inspect";
    var insMsg2 = "Hover over a node to see details";
    var insMsg3 = "Press the 'n' key to go into 'Navigate' mode";

    // Start out in 'Navigate' mode
    var currentMode = mode.NAVIGATE;
    d3.select("#selectorMsg1").text(navMsg1);
    d3.select("#selectorMsg2").text(navMsg2);
    d3.select("#selectorMsg3").text(navMsg3)

    d3.select('body')
        .on("keypress", function () {
            if (d3.event.key === "i") {
                currentMode = mode.INSPECT;
                d3.select("#selectorMsg1").text(insMsg1);
                d3.select("#selectorMsg2").text(insMsg2);
                d3.select("#selectorMsg3").text(insMsg3);

            } else if (d3.event.key === "n") {
                currentMode = mode.NAVIGATE;
                d3.select("#selectorMsg1").text(navMsg1);
                d3.select("#selectorMsg2").text(navMsg2);
                d3.select("#selectorMsg3").text(navMsg3);

            } else {
                // do nothing
            }
        });


    var i = 0, // used for node id's
        fileName = "helm-data.json", // the name of the file containing the helm data
        duration = 750,  // controls the speed at which a tree node opens
        detailsHeight = 290,  // controls the height of the details shown in 'inspection node'
        detailsWidth = 400,   // controls the width of the details shown in 'inspection node'
        root, // the root of the tree
        MAXNAMELENGTH = 30, // max name of chart or image to be displayed in details
        treeData // where the data is loaded

    // declares a tree layout and assigns the size
    var treeMap = d3.tree().size([height, width]);
    d3.json(fileName).then(function(treeData) {

        // Assign the tree root and position it in the middle of
        // svg
        root = d3.hierarchy(treeData, function (d) {
            return d.children;
        });
        root.x0 = height / 2;
        root.y0 = 0;

        // The tree starts up with the first two levels shown
        // TODO Think whether users want to see the whole tree first since most are pretty shallow
        root.children.forEach(collapse);

        // The inspector node is what surfaces when hovering over a node
        // when in inspect mode
        var inspectorNode = d3.select('svg')
            .append('g')
            .attr("id", "g2")
            .append('rect')
            .attr('id', 'i1')
            .attr('x', -800)
            .attr('y', -800)
            .attr('class', 'inspector')
            .style('opacity', '0');

        // When the user hovers over the inspector set the opacity so it pops
        d3.select("#i1")
            .on('mouseover', function (d) {
                if (currentMode === mode.INSPECT) {
                    d3.select("#i1").style('opacity', 1.0);
                    d3.select(this).style("cursor", "pointer")
                }
            })

      .attr('y', 55);

        /**
         * Collapse a node and all its children
         *
         * @param {object} d the node data
         * @returns null
         */
        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null
            }
        }

        // update the tree starting with the root node
        update(root);

        /**
         * Update the tree starting at some point in the tree
         *
         * @param {object} source the node at which point update is done
         * @returns null
         */
        function update(source) {

            var treeData = treeMap(root);

            var nodes = treeData.descendants(),
                links = treeData.descendants().slice(1);

            // each parent-child layer in the tree is a fixed distance
            nodes.forEach(function (d) {
                d.y = d.depth * 270  // TODO derive from style sheets rect width value
            });

            // update the nodes with an id
            var node = svg.selectAll('g.node')
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i)
                });

            var nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr("transform", function (d) {
                    return "translate(" + source.y0 + "," + source.x0 + ")";
                })
                .on('click', click);

            // add a rectangle for each new tree node and add the mouse functions
            nodeEnter.append('rect')
                // if the user hovers over the rectangle then change the
                // pointer and surface the inspector view and format the details
                // if in inspection mode
                .on("mouseover", function (d) {
                    d3.select(this).style("cursor", "pointer");
                    if (currentMode === mode.INSPECT) {
                        var t = d3.select(this);
                        inspectorNode.style('opacity', 1.0)
                            .attr('x', d.y0 + 28)
                            .attr('y', d.x0 - 60);
                        formatDetails(d3.select("#g2"), d)
                    }
                })
                // When leaving the rectangle restore the mouse pointer
                .on("mouseout", function (d) {
                    d3.select(this).style("cursor", "default")
                })

            // use the Helm chart name or image name for the node label
            nodeEnter.append('text')
                .attr("dy", ".35em")
                .attr("x", function (d) {
                    return -42
                })
                .text(function (d) {
                    return truncateName(d.data.name, MAXNAMELENGTH);
                });

            var nodeUpdate = nodeEnter.merge(node);

            // move the updated nodes to where they should be
            nodeUpdate.transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + d.y + "," + d.x + ")"
                })

            // set the rectangle color to provide an indicator of whether a node
            // has visible children or not so the user knows whether there is more
            // information available by clicking on the node in navigation mode.
            nodeUpdate.select("rect").style("fill", function (d) {
                return d._children ? "lightgrey" : "#fff"
            })

            // remove any nodes that should disappear because of collapsing
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + source.y + "," + source.x + ")";
                })
                .remove()

            // on exit reduce the opacity of text labels
            // to avoid the user seeing the text as it is
            // replaced which would look weird
            nodeExit.select('text')
                .style('fill-opacity', 1e-6);

            var link = svg.selectAll('path.link')
                .data(links, function (d) {
                    return d.id;
                });

            // attach any new nodes that have appeared
            var linkEnter = link.enter().insert('path', "g")
                .attr("class", "link")
                .attr('d', function (d) {
                    var o = {x: source.x0, y: source.y0};
                    return diagonal(o, o)
                });

            var linkUpdate = linkEnter.merge(link);

            linkUpdate.transition()
                .duration(duration)
                .attr('d', function (d) {
                    return diagonal(d, d.parent)
                });

            // remove any links that should disappear because of collapsing
            var linkExit = link.exit().transition()
                .duration(duration)
                .attr('d', function (d) {
                    var o = {x: source.x, y: source.y};
                    return diagonal(o, o)
                })
                .remove();

            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            /**
             * Compute a path that will produce a pleasing
             * smooth line
             *
             * @param {object} s coordinates
             * @param {object} d coordinates
             * @returns null
             */
            function diagonal(s, d) {
                path = `M ${s.y} ${s.x}
                            C ${(s.y + d.y) / 2} ${s.x},
                              ${(s.y + d.y) / 2} ${d.x},
                              ${d.y} ${d.x}`;
                return path
            }

            /**
             * Handle click event by toggling the children's visibility
             * _children is the pointer to hidden children
             * children is the pointer to visible children
             *
             * @param {object} d the node data
             * @returns null
             */
            function click(d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    d._children = null;
                }
                update(d);
            }

            /**
             * Formats the description for a single node in the tree when in
             * inspection mode
             *
             * @param {object} t the element to append to.  Note this is an element
             *                   that is selected using d3.select, not a DOM element
             * @param {object} d the data object
             * @return null
             */
            function formatDetails(t, d) {
                // create a foreign object so html can be used for text formatting
                // of the node details
                fo = t.append('foreignObject')
                    .attr("id", "fo")
                    .attr('x', d.y0 + 30)
                    .attr('y', d.x0 - 70)
                    .attr("height", detailsHeight)
                    .attr("width", detailsWidth - 3)
                    // on mouse out move the inspector out of the way and then remove the foreign object itself
                    .on("mouseout", function (d) {
                        d3.select("#i1")
                            .style('opacity', 0)
                            .attr('x', -800)
                            .attr('y', -800);
                        d3.select("#fo")
                            .remove()
                    })
                var div = fo.append('xhtml:div')
                    .append('div');
                var p = div.append("p")
                    .attr('class', 'detailstext');

                // format the details using html
                var s = "<h2 style=\"text-align:center\">" + d.data["name"] + "<hr></h2>";
                var i = 0;  // line counter of actual text

                // the reason I don't just iterate through the array of values in the JSON
                // file is that order of those elemenets is random and I want them in a
                // prescribed order; I also want to filter the properties by type
                var details;
                if (d.data["type"] === "chart") {
                    details = formatChartDetails(d)
                }
                else {
                    details = formatImageDetails(d)
                }
                s += details["details"];
                i += details["lines"];
                // pad the rectangle with spaces so the mouse doesn't get confused
                // by the underlying rectangle
                while (++i < 13) {
                    for (var j = 0, z =""; j < 74; j++) { z+="&nbsp;"}
                    s+="<br/>"+ z
                }
                p.html(s)
            }
            /**
             * Formats the description for a chart
             *
             * @param {object} d the data for the element
             * @return {object} object containing the details and the number of lines
             */
            function formatChartDetails(d) {
                // if the name is really long then truncate.  The full name is in the header anyway
                var s = "&nbsp;" + "name" + ": " + d.data["name"] + "<br/>";
                s += "&nbsp;" + "type" + ": " + d.data["type"] + "<br/>";
                s += "&nbsp;" + "version" + ": " + d.data["version"] + "<br/>";
                s += "&nbsp;" + "description" + ": " + formatValue(d.data["description"]) + "<br/>";
                s += "&nbsp;" + "maintainers" + ": " + formatMaintainers(d.data["maintainers"]) + "<br/>";
                s += "&nbsp;" + "keywords" + ": " + formatValue(d.data["keywords"]) + "<br/>";
                return {"details":s, "lines": 6}
            }
            /**
             * Formats the description for an image
             *
             * @param {object} d the data for the element
             * @return {object} object containing the details and the number of lines
             */
            function formatImageDetails(d) {
                // if the name is really long then truncate.  The full name is in the header anyway
                var s = "&nbsp;" + "name" + ": " + d.data["name"] + "<br/>";
                s += "&nbsp;" + "type" + ": " + d.data["type"] + "<br/>";
                s += "&nbsp;" + "version" + ": " + formatValue(d.data["version"]) + "<br/>";
                s += "&nbsp;" + "repoHost" + ": " + formatValue(d.data["repoHost"]) + "<br/>";
                return {"details":s, "lines": 4}
            }

            /**
             * Provides a readable version of a value by, for example,
             * checking for null
             *
             * @param {object} s the string to be formatted
             * @return string containing more readable version of the string
             */
            function formatValue(s) {
                if (s == null) {
                    return "not specified"
                }
                return s
            }

            /**
             * Provides a readable version of the maintainers property
             * checking for null
             *
             * @param {object} a an array of maintainers
             * @return string containing more readable version of the string
             */
            function formatMaintainers(a) {
                if (a == null) {
                    return "not specified";
                }
                // otherwise this is array of maintainers objects which
                // may be just email or both name and email
                var s = "&nbsp;";
                for (var i in a)
                {
                    if (i > 0) { s += ","}
                    var name = a[i]["name"];
                    var email = a[i]["email"];
                    if (email != null) {
                        s += name + "(" + email + ")";
                    } else {
                        s += name;
                    }
                }
                return s
            }
            /**
             * Shortens a name, adding an ellipsis if needed
             *
             * @param {string} s the string to be shortened
             * @param {int} n max size of the string before shortening will be done
             * @return string containing more readable version of the string
             */
             function truncateName(s, n) {
                 var t;
                 var e = "...";
                 if (s.length > n) {
                     t = s.substring(0, n-e.length);
                     t += e;
                     return t;
                 }
                 return s;
             }
        }
    })
</script>
</body>